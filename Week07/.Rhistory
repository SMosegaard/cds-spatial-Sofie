a <- tm_shape(viking_munic) + tm_polygons(col = "NAME_2", style = "pretty", n = 5)
# "Jenks" = further smooths over the gaps.Identifies groups of similar values in the data and maximizes the differences between categories
b <- tm_shape(viking_munic) + tm_polygons(col = "NAME_2", style = "jenks", n = 5)
# quantile = divides into 5 even groups (ensures same number of observations in each category). But, the bin ranges can vary widely.
c <- tm_shape(viking_munic) + tm_polygons(col = "NAME_2", style = "quantile", n = 5)
# Equal interval style divides the distribution into even groups (equal range). Is appropriate for variables with a uniform distrubution
d <- tm_shape(viking_munic) + tm_polygons(col = "NAME_2", style = "equal", n = 5)
# Write maps above to objects and plot them side by side with tmap_arrange() for better comparison
tmap_arrange(a, b, c, d)
# OBS! I get an error, so I havde changes "col = "n"" to "NAME_2" for all:
# pretty style rounds legend numbers. Default style.
a <- tm_shape(viking_munic) + tm_polygons(col = "viking_count", style = "pretty", n = 5)
# "Jenks" = further smooths over the gaps.Identifies groups of similar values in the data and maximizes the differences between categories
b <- tm_shape(viking_munic) + tm_polygons(col = "viking_count", style = "jenks", n = 5)
# quantile = divides into 5 even groups (ensures same number of observations in each category). But, the bin ranges can vary widely.
c <- tm_shape(viking_munic) + tm_polygons(col = "viking_count", style = "quantile", n = 5)
# Equal interval style divides the distribution into even groups (equal range). Is appropriate for variables with a uniform distrubution
d <- tm_shape(viking_munic) + tm_polygons(col = "viking_count", style = "equal", n = 5)
# Write maps above to objects and plot them side by side with tmap_arrange() for better comparison
tmap_arrange(a, b, c, d)
head(viking_munic)
# OBS! I get an error, so I havde changes "col = "n"" to "NAME_2" for all:
# pretty style rounds legend numbers. Default style.
a <- tm_shape(munic) + tm_polygons(col = "NAME_2", style = "pretty", n = 5)
# "Jenks" = further smooths over the gaps.Identifies groups of similar values in the data and maximizes the differences between categories
b <- tm_shape(munic) + tm_polygons(col = "NAME_2", style = "jenks", n = 5)
# quantile = divides into 5 even groups (ensures same number of observations in each category). But, the bin ranges can vary widely.
c <- tm_shape(munic) + tm_polygons(col = "NAME_2", style = "quantile", n = 5)
# Equal interval style divides the distribution into even groups (equal range). Is appropriate for variables with a uniform distrubution
d <- tm_shape(munic) + tm_polygons(col = "NAME_2", style = "equal", n = 5)
# Write maps above to objects and plot them side by side with tmap_arrange() for better comparison
tmap_arrange(a, b, c, d)
library(tmap)
# pretty style rounds legend numbers. Default style.
a <- tm_shape(viking_munic) +
tm_symbols(col = "viking_count", style = "pretty", n = 5)
# "Jenks" = further smooths over the gaps.Identifies groups of similar values in the data and maximizes the differences between categories
b <- tm_shape(viking_munic) +
tm_symbols(col = "viking_count", style = "jenks", n = 5)
# quantile = divides into 5 even groups (ensures same number of observations in each category). But, the bin ranges can vary widely.
c <- tm_shape(viking_munic) +
tm_symbols(col = "viking_count", style = "quantile", n = 5)
# Equal interval style divides the distribution into even groups (equal range). Is appropriate for variables with a uniform distribution
d <- tm_shape(viking_munic) +
tm_symbols(col = "viking_count", style = "equal", n = 5)
# Write maps above to objects and plot them side by side with tmap_arrange() for better comparison
tmap_arrange(a, b, c, d)
library(tmap)
# pretty style rounds legend numbers. Default style.
a <- tm_shape(viking_munic) +
tm_symbols(col = "viking_count", style = "pretty", n = 0.1)
# "Jenks" = further smooths over the gaps.Identifies groups of similar values in the data and maximizes the differences between categories
b <- tm_shape(viking_munic) +
tm_symbols(col = "viking_count", style = "jenks", n = 1)
# quantile = divides into 5 even groups (ensures same number of observations in each category). But, the bin ranges can vary widely.
c <- tm_shape(viking_munic) +
tm_symbols(col = "viking_count", style = "quantile", n = 10)
# Equal interval style divides the distribution into even groups (equal range). Is appropriate for variables with a uniform distribution
d <- tm_shape(viking_munic) +
tm_symbols(col = "viking_count", style = "equal", n = 100)
# Write maps above to objects and plot them side by side with tmap_arrange() for better comparison
tmap_arrange(a, b, c, d)
library(tmap)
# pretty style rounds legend numbers. Default style.
a <- tm_shape(viking_munic) +
tm_symbols(col = "viking_count", style = "pretty", n = 2)
# "Jenks" = further smooths over the gaps.Identifies groups of similar values in the data and maximizes the differences between categories
b <- tm_shape(viking_munic) +
tm_symbols(col = "viking_count", style = "jenks", n = 5)
# quantile = divides into 5 even groups (ensures same number of observations in each category). But, the bin ranges can vary widely.
c <- tm_shape(viking_munic) +
tm_symbols(col = "viking_count", style = "quantile", n = 10)
# Equal interval style divides the distribution into even groups (equal range). Is appropriate for variables with a uniform distribution
d <- tm_shape(viking_munic) +
tm_symbols(col = "viking_count", style = "equal", n = 100)
# Write maps above to objects and plot them side by side with tmap_arrange() for better comparison
tmap_arrange(a, b, c, d)
library(tmap)
# pretty style rounds legend numbers. Default style.
a <- tm_shape(viking_munic) + tm_polygons()+
tm_symbols(col = "viking_count", style = "pretty", n = 2)
# "Jenks" = further smooths over the gaps.Identifies groups of similar values in the data and maximizes the differences between categories
b <- tm_shape(viking_munic) + tm_polygons()+
tm_symbols(col = "viking_count", style = "jenks", n = 5)
# quantile = divides into 5 even groups (ensures same number of observations in each category). But, the bin ranges can vary widely.
c <- tm_shape(viking_munic) + tm_polygons()+
tm_symbols(col = "viking_count", style = "quantile", n = 10)
# Equal interval style divides the distribution into even groups (equal range). Is appropriate for variables with a uniform distribution
d <- tm_shape(viking_munic) + tm_polygons()+
tm_symbols(col = "viking_count", style = "equal", n = 100)
# Write maps above to objects and plot them side by side with tmap_arrange() for better comparison
tmap_arrange(a, b, c, d)
a2 <- tm_shape(viking_munic) + tm_polygons(fill = "viking_count", style = "pretty", n = 5)
b2 <- tm_shape(viking_munic) + tm_polygons(fill = "viking_count", style = "jenks", n = 5)
c2 <- tm_shape(viking_munic) + tm_polygons(fill = "viking_count", style = "quantile", n = 5)
d2 <- tm_shape(viking_munic) + tm_polygons(fill = "viking_count", style = "equal", n = 5)
tmap_arrange(a2, b2, c2, d2)
# Calculate the density of Viking monuments per municipality
viking_munic <- viking_munic %>%
mutate(density = viking_count / st_area(geometry))  # Calculate density as monuments per area
# Choose a color palette for the gradient
palette <- "Blues"
# Plot the map with a gradient color scheme representing the density
map <- tm_shape(viking_munic) +
tm_fill(col = "density", style = "cont", palette = palette, title = "Density of Viking Monuments") +
tm_borders() +  # Add borders for municipalities
tm_layout(legend.position = c("right", "bottom"),
scale.bar.position = c("right", "bottom"),
north.arrow.position = c("right", "top")) +
tm_title("Density of Viking Monuments per Municipality")
# Calculate the density of Viking monuments per municipality
viking_munic <- viking_munic %>%
mutate(density = viking_count / st_area(geometry))  # Calculate density as monuments per area
# Choose a color palette for the gradient
palette <- "Blues"
# Plot the map with a gradient color scheme representing the density
map <- tm_shape(viking_munic) +
tm_fill(col = "density", style = "cont", palette = palette, title = "Density of Viking Monuments") +
tm_borders()
# Save the map as a PDF
pdf("municmap.pdf")
print(map)
tmap_arrange(map)
a <- tm_shape(viking_munic) + tm_polygons()+
tm_symbols(col = "viking_count", style = "pretty", n = 2, size = 0.5)
tmap_arrange(a, b, c, d)
# tm_symbols
a <- tm_shape(viking_munic) + tm_polygons()+
tm_symbols(col = "viking_count", style = "pretty", n = 2, size = 1)
b <- tm_shape(viking_munic) + tm_polygons()+
tm_symbols(col = "viking_count", style = "jenks", n = 5, size = 1)
c <- tm_shape(viking_munic) + tm_polygons()+
tm_symbols(col = "viking_count", style = "quantile", n = 10, size = 1)
d <- tm_shape(viking_munic) + tm_polygons()+
tm_symbols(col = "viking_count", style = "equal", n = 100, size = 1)
tmap_arrange(a, b, c, d)
# Create the maps with gradient symbol styles
a <- tm_shape(viking_munic) +
tm_symbols(col = "viking_count", style = "cont", palette = "Blues", title = "Density of Viking Monuments") +
tm_layout(legend.position = c("right", "bottom")) +
tm_title("Density of Viking Monuments per Municipality")
# Create the maps with gradient symbol styles
a <- tm_shape(viking_munic) +
tm_symbols(col = "viking_count", style = "cont", palette = "Blues", title = "Density of Viking Monuments")
# Create the maps with gradient fill colors based on the count of Viking monuments
a <- tm_shape(viking_munic) +
tm_polygons(col = "viking_count", style = "cont", palette = "Blues", title = "Density of Viking Monuments")
b <- tm_shape(viking_munic) +
tm_polygons(col = "viking_count", style = "cont", palette = "Blues", title = "Density of Viking Monuments")
c <- tm_shape(viking_munic) +
tm_polygons(col = "viking_count", style = "cont", palette = "Blues", title = "Density of Viking Monuments")
d <- tm_shape(viking_munic) +
tm_polygons(col = "viking_count", style = "cont", palette = "Blues", title = "Density of Viking Monuments")
# Plot the maps side by side for comparison
tmap_arrange(a, b, c, d)
# Create the maps with gradient fill colors based on the count of Viking monuments
a <- tm_shape(viking_munic) +
tm_fill(col = "viking_count", style = "cont", palette = "Blues", title = "Density of Viking Monuments")
b <- tm_shape(viking_munic) +
tm_fill(col = "viking_count", style = "cont", palette = "Blues", title = "Density of Viking Monuments")
c <- tm_shape(viking_munic) +
tm_fill(col = "viking_count", style = "cont", palette = "Blues", title = "Density of Viking Monuments")
d <- tm_shape(viking_munic) +
tm_fill(col = "viking_count", style = "cont", palette = "Blues", title = "Density of Viking Monuments")
# Plot the maps side by side for comparison
tmap_arrange(a, b, c, d)
library(tmap)
# Check the structure of the viking_munic dataset
str(viking_munic)
# Plot the map with gradient fill colors based on the count of Viking monuments
map <- tm_shape(viking_munic) +
tm_fill(col = "viking_count", style = "cont", palette = "Blues", title = "Density of Viking Monuments") +
tm_layout(legend.position = c("right", "bottom")) +
tm_title("Density of Viking Monuments per Municipality")
library(tmap)
# Plot the map with gradient fill colors based on the count of Viking monuments
map <- tm_shape(viking_munic) +
tm_fill(col = "viking_count", style = "cont", palette = "Blues", title = "Density of Viking Monuments") +
tm_layout(legend.position = c("right", "bottom")) +
tm_main_title("Density of Viking Monuments per Municipality")  # Corrected function name
library(tmap)
# Plot the map with gradient fill colors based on the count of Viking monuments
map <- tm_shape(viking_munic) +
tm_fill(col = "viking_count", style = "cont", palette = "Blues", title = "Density of Viking Monuments") +
tm_layout(legend.position = c("right", "bottom"))
# Print the map
print(map)
library(tmap)
# Create the maps with gradient fill colors based on the count of Viking monuments
a <- tm_shape(viking_munic) +
tm_fill(col = "viking_count", style = "cont", palette = "Blues", title = "Density of Viking Monuments")
b <- tm_shape(viking_munic) +
tm_fill(col = "viking_count", style = "cont", palette = "Blues", title = "Density of Viking Monuments")
c <- tm_shape(viking_munic) +
tm_fill(col = "viking_count", style = "cont", palette = "Blues", title = "Density of Viking Monuments")
d <- tm_shape(viking_munic) +
tm_fill(col = "viking_count", style = "cont", palette = "Blues", title = "Density of Viking Monuments")
# Plot the maps side by side for comparison
tmap_arrange(a, b, c, d)
tm_shape(viking_munic) +
tm_fill()
tm_shape(viking_munic) + tm_fill(fill = "viking_count")
tm_shape(viking_munic) + tm_fill(fill = "NAME_2")
# Check the structure of the viking_munic dataset
str(viking_munic)
# Plot each map separately
a <- tm_shape(viking_munic) +
tm_fill(col = "viking_count", style = "cont", palette = "Blues", title = "Density of Viking Monuments")
b <- tm_shape(viking_munic) +
tm_fill(col = "viking_count", style = "cont", palette = "Blues", title = "Density of Viking Monuments")
c <- tm_shape(viking_munic) +
tm_fill(col = "viking_count", style = "cont", palette = "Blues", title = "Density of Viking Monuments")
d <- tm_shape(viking_munic) +
tm_fill(col = "viking_count", style = "cont", palette = "Blues", title = "Density of Viking Monuments")
# Plot the maps side by side for comparison
tmap_arrange(a, b, c, d)
library(knitr)
library(rmdformats)
## Global options
options(max.print="75")
opts_chunk$set(echo=TRUE,
cache=TRUE,
prompt=FALSE,
tidy=TRUE,
comment=NA,
message=FALSE,
warning=FALSE)
opts_knit$set(width=75)
library(sf)
library(raster)
library(tmap)
# Load datasets distribution
munic <- readRDS("../data/gadm36_DNK_2_sp.rds")
munic <- munic %>%
st_as_sf()%>%
st_transform(crs=25832) #making munic compatible with viking
viking
all.equal(crs(munic),crs(viking))
#true
#approach 1: sptial joun
munic_viking <- munic%>%
st_join(viking)
library(tidyverse, mapview)
munic_viking <- munic_viking%>%
group_by(NAME_2)%>% #group by municipality
tally() #%>%
#arrange(desc(n)) #can arraange by number
mapview(munic_viking, zcol="n")
View(munic_viking)
viking_munic <-  munic%>%
st_join(viking)
# Load datasets distribution
munic <- readRDS("../data/gadm36_DNK_2_sp.rds")
viking <- readRDS("../data/viking.rds")
# Convert munic to sf
munic <- st_as_sf(munic)
# Convert sf objects to match (which is at 25832 crs)
munic <- st_transform(munic, crs = st_crs(viking))
# Perform a spatial join (to join the viking monuments with the municipality information)
#viking_munic <- st_join(viking, munic, join = st_within)
viking_munic <-  munic%>%
st_join(viking)
# Summarize to get the count of Viking monuments per municipality
viking_munic <- viking_munic %>%
group_by(NAME_2) %>%            # NAME_2 = municipality
summarise(viking_count = n())   # column with the number of monuments per municipality
# Does this answer "Calculate the density of viking monuments per municipality" by either"??
of classes.
a <- tm_shape(munic_viking) + tm_polygons(col = "n", style = "pretty", n = 5)
# "Jenks" style further smooths over the gaps
b <- tm_shape(munic_viking) + tm_polygons(col = "n", style = "jenks", n = 6)
# quantile style divides into 5 even groups
c <- tm_shape(munic_viking) + tm_polygons(col = "n", style = "quantile", n=5)
# Equal interval style divides the distribution into even groups
d <- tm_shape(munic_viking) + tm_polygons(col = "n", style = "equal", n = 5)
# Write maps above to objects and plot them side by side
# with tmap_arrange() for better comparison
#can change number of categories
tmap_arrange( a,b, c,d)
a <- tm_shape(viking_munic) + tm_polygons(col = "n", style = "pretty", n = 5)
# "Jenks" style further smooths over the gaps
b <- tm_shape(viking_munic) + tm_polygons(col = "n", style = "jenks", n = 6)
# quantile style divides into 5 even groups
c <- tm_shape(viking_munic) + tm_polygons(col = "n", style = "quantile", n=5)
# Equal interval style divides the distribution into even groups
d <- tm_shape(viking_munic) + tm_polygons(col = "n", style = "equal", n = 5)
# Write maps above to objects and plot them side by side
# with tmap_arrange() for better comparison
#can change number of categories
tmap_arrange( a,b, c,d)
# Load datasets distribution
munic <- readRDS("../data/gadm36_DNK_2_sp.rds")
viking <- readRDS("../data/viking.rds")
# Convert munic to sf
munic <- st_as_sf(munic)
# Convert sf objects to match (which is at 25832 crs)
munic <- st_transform(munic, crs = st_crs(viking))
# Perform a spatial join (to join the viking monuments with the municipality information)
#viking_munic <- st_join(viking, munic, join = st_within)
viking_munic <-  munic%>%
st_join(viking)
# Summarize to get the count of Viking monuments per municipality
#viking_munic <- viking_munic %>%
#  group_by(NAME_2) %>%            # NAME_2 = municipality
#  summarise(viking_count = n())   # column with the number of monuments per municipality
viking_munic <- viking_munic%>%
group_by(NAME_2)%>% #group by municipality
tally() #%>%
# Does this answer "Calculate the density of viking monuments per municipality" by either"??
a <- tm_shape(viking_munic) + tm_polygons(col = "n", style = "pretty", n = 5)
# "Jenks" style further smooths over the gaps
b <- tm_shape(viking_munic) + tm_polygons(col = "n", style = "jenks", n = 6)
# quantile style divides into 5 even groups
c <- tm_shape(viking_munic) + tm_polygons(col = "n", style = "quantile", n=5)
# Equal interval style divides the distribution into even groups
d <- tm_shape(viking_munic) + tm_polygons(col = "n", style = "equal", n = 5)
# Write maps above to objects and plot them side by side
# with tmap_arrange() for better comparison
#can change number of categories
tmap_arrange( a,b, c,d)
# pretty style rounds legend numbers. Default style.
a <- tm_shape(viking_munic) + tm_polygons(col = "n", style = "pretty", n = 5)
# "Jenks" = further smooths over the gaps.Identifies groups of similar values in the data and maximizes the differences between categories
b <- tm_shape(viking_munic) + tm_polygons(col = "n", style = "jenks", n = 6)
# quantile = divides into 5 even groups (ensures same number of observations in each category). But, the bin ranges can vary widely.
c <- tm_shape(viking_munic) + tm_polygons(col = "n", style = "quantile", n=5)
# Equal interval style divides the distribution into even groups (equal range). Is appropriate for variables with a uniform distrubution
d <- tm_shape(viking_munic) + tm_polygons(col = "n", style = "equal", n = 5)
# Write maps above to objects and plot them side by side with tmap_arrange() for better comparison
tmap_arrange(a, b, c, d)
# tm_symbols
a <- tm_shape(viking_munic) + tm_polygons()+
tm_symbols(col = "viking_count", style = "pretty", n = 2, size = 1)
b <- tm_shape(viking_munic) + tm_polygons()+
tm_symbols(col = "viking_count", style = "jenks", n = 5, size = 1)
c <- tm_shape(viking_munic) + tm_polygons()+
tm_symbols(col = "viking_count", style = "quantile", n = 10, size = 1)
d <- tm_shape(viking_munic) + tm_polygons()+
tm_symbols(col = "viking_count", style = "equal", n = 100, size = 1)
tmap_arrange(a, b, c, d)
map <- tm_shape(munic) + tm_polygons(col = "NAME_2", style = "quantile", n = 5)
c <- tm_shape(munic) + tm_polygons(col = "NAME_2", style = "quantile", n = 5)
map <- tm_shape(munic) +
tm_polygons(col = "NAME_2", style = "quantile", n = 5, palette = "RdYlBu", title = "Density of Viking Monuments") +
tm_layout(legend.position = c("right", "bottom"),
scale.bar.position = c("right", "bottom"),
north.arrow.position = c("right", "top")) +
tm_title("Density of Viking Monuments per Municipality") +
tm_format(legend.title = "Density")
library(knitr)
library(rmdformats)
## Global options
options(max.print="75")
opts_chunk$set(echo=TRUE,
cache=TRUE,
prompt=FALSE,
tidy=TRUE,
comment=NA,
message=FALSE,
warning=FALSE)
opts_knit$set(width=75)
library(sf)
library(tidyverse)
library(googlesheets4)
library(leaflet)
# Bring in a choice of Esri background layers
l_cp <- leaflet() %>%   # assign the base location to an object
setView(12.56553, 55.675946, zoom = 11)
#l_cp %>% addTiles()
esri <- grep("^Esri", providers, value = TRUE)
for (provider in esri) {
l_cp <- l_cp %>% addProviderTiles(provider, group = provider)
}
# Create the map
MapCPH <- l_cp %>%
addLayersControl(baseGroups = names(esri),
options = layersControlOptions(collapsed = FALSE)) %>%
addMiniMap(tiles = esri[[1]], toggleDisplay = TRUE,
position = "bottomright") %>%
addMeasure(
position = "bottomleft",
primaryLengthUnit = "meters",
primaryAreaUnit = "sqmeters",
activeColor = "#3D535D",
completedColor = "#7D4479") %>%
htmlwidgets::onRender("
function(el, x) {
var myMap = this;
myMap.on('baselayerchange',
function (e) {
myMap.minimap.changeLayer(L.tileLayer.provider(e.name));
})
}")%>%
addControl("", position = "topright")
MapCPH
# Load data from Googlesheet (deauthorize your connection with gs4_deauth() if read_sheet() gives you trouble)
gs4_deauth()
baths <- read_sheet("https://docs.google.com/spreadsheets/d/15i17dqdsRYv6tdboZIlxTmhdcaN-JtgySMXIXwb5WfE/edit#gid=0",
col_types = "ccnnncnnnc")
# Prepare a color palette to reflect spatial precision of points
glimpse(factor(baths$Quality))  # check the Quality values
factpal <- colorNumeric(c("navy", "red", "grey"), 1:3) # prepare scale
factpal(c(1,1,2)) # test the scale works
# Read the bath coordinates and names into map
Bathsmap <- MapCPH %>% addCircleMarkers(lng=baths$Longitude,
lat=baths$Latitude,
radius=baths$Quality*3,
color = factpal(baths$Quality),
popup = paste0("Name: ", baths$BathhouseName,
"<br> Notes: ", baths$Notes))
Bathsmap
# Load data from Googlesheet (deauthorize your connection with gs4_deauth() if read_sheet() gives you trouble)
gs4_deauth()
baths <- read_sheet("https://docs.google.com/spreadsheets/d/15i17dqdsRYv6tdboZIlxTmhdcaN-JtgySMXIXwb5WfE/edit#gid=0",
col_types = "ccnnncnnnc")
# Prepare a color palette to reflect spatial precision of points
glimpse(factor(baths$Quality))  # check the Quality values
factpal <- colorNumeric(c("navy", "red", "grey"), 1:3) # prepare scale
factpal(c(1,1,2)) # test the scale works
# Read the bath coordinates and names into map
Bathsmap <- MapCPH %>% addCircleMarkers(lng=baths$Longitude,
lat=baths$Latitude,
radius=baths$Quality*3,
color = factpal(baths$Quality),
popup = paste0("Name: ", baths$BathhouseName,
"<br> Notes: ", baths$Notes))
Bathsmap
# Save map as a html document, beware that it only works in root directory
library(htmlwidgets)
saveWidget(Bathsmap, "Bathhousemap.html", selfcontained = TRUE)
# Save map as a html document, beware that it only works in root directory
library(htmlwidgets)
saveWidget(Bathsmap, "Bathhousemap.html", selfcontained = TRUE)
library(knitr)
library(rmdformats)
## Global options
options(max.print="75")
opts_chunk$set(echo=TRUE,
cache=TRUE,
prompt=FALSE,
tidy=TRUE,
comment=NA,
message=FALSE,
warning=FALSE)
opts_knit$set(width=75)
library(sf)
library(tidyverse)
library(googlesheets4)
library(leaflet)
# Your code
wcdata %>% group_by(year) %>%
summarize(flatsC = sum(flats),
bathC = sum(bath),
pct_bathaccess=bathC/flatsC*100)
library(knitr)
library(rmdformats)
## Global options
options(max.print="75")
opts_chunk$set(echo=TRUE,
cache=TRUE,
prompt=FALSE,
tidy=TRUE,
comment=NA,
message=FALSE,
warning=FALSE)
opts_knit$set(width=75)
library(sf)
library(tidyverse)
library(googlesheets4)
library(leaflet)
suburbs <- st_read("../data/bydel.shp", options= "ENCODING=WINDOWS-1252")
# this could work if the option above still give off names
#suburbs <- suburbs%>%
#st_as_sf(suburbs, fileEncoding="windows-1252" )
suburbs$navn
suburbs$id
# Uncomment the lines below to read data from GDrive
# wc <- read_sheet("https://docs.google.com/spreadsheets/d/1iFvycp6M6bF8GBkGjA2Yde2yCIhiy5_slAkGF-RUF7w/edit#gid=0",
#                     col_types = "cnnnnnnnn")
wc <- read_csv("../data/wc.csv")
# Check out the data and try to grasp what is being summarized in the columns
wc
unique(wc$Suburb)
unique(suburbs$navn)
#obs different count of surburbs
#the
suburbs$id
#the id column is used to combine
wcdata <- wc %>%
group_by(year, suburb_id) %>%
summarize(flatssum = sum(flats), #total number of flats by suburb
bathsum = sum(bath), #total number of baths by suburb
pct_bath = bathsum/flatssum*100, #percentage of flats with baths in a suburb
wc_accesssum= sum(wc_access),  #total number of toilets by suburb
pct_wc= wc_accesssum/flatssum*100, #percentage of flats with toilets in a suburb
warmH20=sum(hot_water),    #total number of hot water taps by suburb
pct_wH20=hot_water/flatssum*100,  # percentage of flats with hot water taps
communal_wc = sum(wc_communal_ct),  #total number of communal toilets by suburb
communal_bath = sum(bath_communal_ct) ) #total number of communal baths by suburb
wcdata
# Your code
wcdata %>% group_by(year) %>%
summarize(flatsC = sum(flatssum),
bathC = sum(bathsum),
pct_bathaccess=bathC/flatsC*100)
wcdata %>% group_by(year) %>%
summarize(flatsC = sum(flatssum),
wcC = sum(wc_accesssum),
pct_wcaccessC=wcC/flatsC*100)
wc_spatial <- suburbs %>%
merge(wcdata, by.x= "id",by.y ="suburb_id")
wc_spatial
